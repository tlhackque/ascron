#!/usr/bin/perl

my $copyright =
    "Copyright (c) 2022 Timothe Litt litt _at acm.org\nUse --man for license.";

# cron timespec decoding largely from Schedule::Cron

# Run a job once, in cron context

use warnings;
use strict;

our $VERSION = 'V1.0.10';

use Cwd(   qw/realpath getcwd/ );
use Errno( qw/EAGAIN/ );
use Fcntl( qw/:seek :mode/ );
use File::Basename;
use File::Temp;
use Getopt::Long( qw(:config bundling) );
use POSIX(        qw/:sys_wait_h setlocale LC_ALL LC_COLLATE setsid strftime/ );
use Sys::Hostname;
use Text::Abbrev;

sub dojob;
sub timeof;
sub xtime;
sub nearest;
sub debug;
sub procsts;

my $SELF = basename $0;
my @argv = @ARGV;

# The following is distribution-specific

my( $usertable, @systables ) = (
       (  -d '/var/spool/cron/crontabs'
          ? '/var/spool/cron/crontabs/%s'
          : '/var/spool/cron/%s' ),
       '/etc/crontab',
       '/etc/cron.d/*' );
my $systableRE  = join( '|', map { my $d = $_; $d =~ s/[*]/.*/g; $d } @systables );
my $usertableRE = sprintf( $usertable, '(.*)' );
my $systable    = '*system*';
my $mailer      = '/usr/lib/sendmail';
my $mailcmd     = "%s -i -F'Cron Daemon' -f %s -odi -oem %s";
my $localtime   = "/etc/localtime";  # Olson timezone; zoneinfo line or file
my $timezone    = "/etc/timezone";   # Debian timezone - contains timezone

# No distribution-specific tailoring should be required from here on

my $defaultUser = getpwuid( $> );
my %emptyenv    = ( SHELL => '/bin/sh', );

$systableRE   = qr/^($systableRE)$/;
$usertableRE  = qr/^$usertableRE$/;
$emptyenv{TZ} = $ENV{TZ} if( defined $ENV{TZ} );

my( $log, $havegtod, $havetimedate, $startt, $startu );

# Time decoding

my @dow = qw( Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday );

# minute hour dom month dow
my @namemap = (
        {},
        {},
        {},
        { jan => 1, feb => 2, mar => 3, apr => 4,  may => 5,  jun => 6,
          jul => 7, aug => 8, sep => 9, oct => 10, nov => 11, dec => 12, },
        { sun => 0, mon => 1, tue => 2, wed => 3, thu => 4, fri => 5, sat => 6, },
);
my @limits = ( [ 0, 59 ],
               [ 0, 23 ],
               [ 0, 31 ],
               [ 0, 12 ],
               [ 0, 7 ],
             );
my @valmap = ( {},
               {},
               { 0 => 1 },
               { 0 => 1 },
               { 7 => 0 },
               {},
             );

# Parse (and default) the command line
my( $debug, $detach, $job,  $match,   $help,
    $list,  $locale, $man,  $pidfile, $sendmail,
    $table, $format, $notz, $user,    $version );

my %formats  = ( abbrev( qw/automatic system user/ ) );
my %sendmail = ( abbrev( qw/discard display send/ ) );

my $ini;
if( defined $ENV{HOME} && open( $ini, "<", "$ENV{HOME}/.$SELF" ) ) {
    require Text::ParseWords;
    my @ini;
    while( <$ini> ) {
        s/\s*#.*$//;
        s/^\s+//;
        s/\s+$//;
        next unless( length );
        push @ini, Text::ParseWords::parse_line( '\s+', 0, $_ );
    }
    close( $ini );
    $ini = realpath( "$ENV{HOME}/.$SELF" );
    unshift @ARGV, @ini;
    unshift @argv, @ini;
} else {
    undef $ini;
}

sub opt_format {
    my( $n, $v ) = @_;
    if( ( my $k = $formats{$v} ) ) {
        $format = $k eq 'automatic' ? undef : $k;
    } else {
        die( "--format must be 'automatic', 'system' or 'user'\n" );
    }
    return;
}

sub opt_mailaction {
    my( $n, $v ) = @_;
    if( ( my $k = $sendmail{$v} ) ) {
        $sendmail = $k;
    } else {
        die( "--mail-action must be 'discard', 'display', or 'send'\n" );
    }
    return;
}

GetOptions(
        'debug|d=s'        => \$debug,
        'nodebug'          => sub { undef $debug; },
        'daemon|detach|D!' => \$detach,
        'job|j'            => \$job,
        'nojob|command|c'  => sub { undef $job; },
        'list|l!'          => \$list,
        'locale|L=s'       => \$locale,
        'nolocale'         => sub { undef $locale; },
        'match|m=i'        => \$match,
        'pidfile|p=s'      => \$pidfile,
        'nopidfile'        => sub { undef $pidfile; },
        'table|t=s'        => \$table,
        'notable'          => sub { undef $table; },
        'user|u=s'         => \$user,
        'nouser'           => sub { undef $user; },
        'format|f=s'       => \&opt_format,
        'mail-action|M=s'  => \&opt_mailaction,
        'system|s'         => sub { $table = $systable; },
        'tz|z=s'           => sub { $emptyenv{TZ} = $_[1]; undef $notz; },
        'notz|Z'           => sub { delete $emptyenv{TZ}; $notz = 1; },
        'help|h'           => \$help,
        'man'              => \$man,
        'version|v+'       => \$version,
          ) or die( "Error in command\n" );

# Handle help, man, & version
if( $help || $man ) {
    eval {
        no warnings 'once';
        $Pod::Usage::Formatter = 'Pod::Text::Termcap';
        require Pod::Usage;
    } or
        die( "Install Pod::Usage or use 'perldoc $0'\n" );
    Pod::Usage::pod2usage( 1 )                            if $help;
    Pod::Usage::pod2usage( -exitval => 0, -verbose => 2 ) if $man;
}

if( $version ) {
    if( $version > 1 ) {
        printf( "%s\n", substr( $VERSION, 1 ) );
    } else {
        printf( "%s version %s\n%s\n", $SELF, $VERSION, $copyright );
    }
    exit 0;
}

# Setup debug logging

if( defined $debug ) {
    if( $debug =~ /^-[[:alnum:]-]+$/ ) {
        die( "--debug requires a filename, but its value ($debug) looks like an option\n" );
    }
    $havegtod = eval {
        require Time::HiRes;
        Time::HiRes->import( qw/gettimeofday/ );
        return 1;
    };
    ( $startt, $startu ) = $havegtod ? gettimeofday() : ( time, 0 );
    if( $debug eq "" || $debug eq '-' ) {
        $debug = \*STDERR;
    } else {
        open( my $df, '>', $debug ) or do {
            printf STDERR ( "Debug: %s:%s\n", $debug, $! );
            exit 1;
        };
        printf STDERR ( "Debug logging to %s\n", $debug );
        $log   = realpath( $debug );
        $debug = $df;
    }
    debug( strftime( "%a %d-%b-%Y", localtime( time ) ) );
    debug( "Read %s\n", $ini ) if( defined $ini && length $ini );
    debug( "%s %s\n", $SELF, join( ' ', @argv ) );
}

$havetimedate =
    eval { require Time::ParseDate; Time::ParseDate->import( qw/parsedate/ ); 1; };
debug( "Time::ParseDate is not installed\n" ) unless( $havetimedate );

# Try to find a reasonable value for TZ
# It shouldn't be this hard...
unless( $notz || exists $emptyenv{TZ} ) {
    my $tz;
    if( open( my $z, '<', $timezone ) ) {
        $tz = <$z>;
        chomp $tz;
        close( $z );
        debug( "TZ set from $timezone" );
    }
    unless( defined $tz && length $tz ) {

        # busybox /bin/sh prints 'no such file' for command before redirects.
        # Don't try to run timedatectl unless we find it on $PATH.
        my $z;
        $z = -x "$_/timedatectl" and last foreach( split /:/, $ENV{PATH} );
        $z = qx(2>/dev/null timedatectl show --property=Timezone) if( $z );

        if( $z && $z =~ m,^Timezone=(.*)$, && length $1 ) {
            $tz = $1;
            debug( "TZ set from timedatectl" );
        } elsif( -l $localtime ) {
            my $syml = $localtime;
            my $wd   = getcwd;
            $syml = "$wd/$syml" if( substr( $syml, 0, 1 ) ne '/' );
            while(     -l $syml
                    && defined( $z = eval { return readlink( $syml ); } )
                    && length $z ) {
                if( substr( $z, 0, 1 ) eq '/' ) {
                    $syml = $z;
                } else {
                    $syml = dirname( $syml ) . "/$z";
                }
            }
            if( ( $syml =~ s,^.*zoneinfo/,, ) && length $syml ) {
                $tz = $syml;
                debug( "TZ set from $localtime" );
            }
        }
        if( !defined $tz && -f $localtime && open( my $z, '<', $localtime ) ) {
            my $s = -s $z;
            seek( $z, -256, SEEK_END ) if( defined $s && $s > 2556 );
            undef $tz;
            $tz = $_ while( <$z> );
            close( $z );
            if( defined $tz && $tz =~ m!^[^:/0-9,+-][^0-9,+-]{2,}[+-]?\d! ) {
                chomp $tz;
                debug( "TZ set from $localtime" );
            } else {
                $tz = ":$localtime";
                debug( "TZ set to :$localtime" );
            }
        }
    }
    if( defined $tz && length $tz ) {
        $emptyenv{TZ} = $tz;
    } else {
        debug( "Unable to determine TZ" );
    }
}

# Handle locale - cron uses the system defaults, except for COLLATE, but we don't
# know what those are for daemons.  The user may have environment variables or settings.
# The system default is probably NOT Perl's "C"; perhaps UTF-8.
#<<<
my $charset = eval {
    require locale;
    if( !defined $locale ) {  # Use the user/system's, e.g. LC_ALL or LANG
        setlocale( LC_ALL, "" );
    } elsif( !defined setlocale( LC_ALL, $locale ) ) {
        debug( "Unable to set locale '%s'\n", $locale );
        printf STDERR ( "Unable to set locale '%s'\n", $locale );
        exit 1;
    } else {
        debug( "Locale set to '%s'\n", $locale );
    }
    setlocale( LC_COLLATE, "C" );
    require I18N::Langinfo;
    I18N::Langinfo->import( qw/langinfo CODESET/ );
    my $cs = langinfo( CODESET() );
    return $cs if( defined $cs && lc $cs ne 'ansi_x3.4-1968' );  # crond's match is case-sensitive, but shouldn't be.
    return;
} || 'US_ASCII';
#>>>
debug( "Codeset %s selected\n", $charset );  # Used for the default Content-Type header

# Output handling
$sendmail = 'send' unless( defined $sendmail );

# Reasonable defaults for the inter-related table, format and user
if( defined $table && ( $table eq $systable || $table =~ /$systableRE/ ) ) {
    $format = 'system';
} elsif( defined $table && !defined $format && $table =~ /$usertableRE/ ) {
    $format = 'user';
    $user   = basename( $table ) unless( defined $user );
} elsif( !defined $table && !defined $format ) {
    if( defined $user ) {
        $table  = sprintf( $usertable, $user );
        $format = 'user';
    } else {
        $format = 'system';
    }
} elsif( !defined $table ) {
    if( $format eq 'system' ) {
        if( !defined $job ) {
            $table  = $systables[0];
            $format = 'system';
        }
    } elsif( defined $user ) {
        $table  = sprintf( $usertable, $user );
        $table  = sprintf( $usertable, $defaultUser ) unless( -f $table );
        $format = 'user';
    } else {
        $table  = sprintf( $usertable, $defaultUser );
        $format = 'user';
    }
} elsif( !defined $format ) {
    $format = 'user';
    $table  = sprintf( $usertable, defined $user ? $user : $defaultUser )
        unless( defined $table );
}

if(    $format eq 'user'
    && defined $user
    && defined $table
    && $table =~ /$usertableRE/
    && $1 ne $user ) {
    printf STDERR (
            "Specified user '%s' does not match table owner '%s' of %s\n", $user,
            $1,                                                            $table );
    exit 1;
}

# Job matching and environment
my( $matchRE, $jobcmd, $hitnum, %env );
$hitnum = 0;
%env    = %emptyenv;

$match = 1 unless( defined $match );

if( defined $job ) {  # Job from a crontab
    unless( @ARGV ) {
        printf STDERR ( "--job requires one or more job strings to match\n" );
        exit 1;
    }
    $matchRE = join( '|', map { "(?:$_)" } @ARGV );  # ?? map { "(?:\Q$_\E)" } @ARGV;
    my $mat = eval { qr/$matchRE/ } or do {
        printf STDERR ( "Invalid match expression: %s\n", $matchRE );
        exit 1;
    };
    $matchRE = $mat;
} else {  # Job from command line
    die( "--list only applies to --job\n" ) if( $list );

    $jobcmd = join( ' ', @ARGV );
}

if( $debug ) {
    debug( "Job location: %s\n", defined $job ? "crontab" : "command line" );
    my %syms = ( table       => $table,
                 format      => $format,
                 user        => $user,
                 defaultUser => $defaultUser,
                 matchRE     => $matchRE,
                 jobcmd      => $jobcmd );
    foreach my $sym ( sort keys %syms ) {
        debug(  "%s => '%s'", $sym,
                defined $syms{$sym} ? $syms{$sym} : 'undef' );
    }
}

# Process table(s) for environment and (if requested) jobs
TABLE:
foreach my $file ( defined $table
                   && $table ne $systable ? $table : glob join( ' ', @systables ) ) {
    debug( "Processing %s", $file );
    unless( -f $file ) {
        printf STDERR ( "%s: Not a regular file, skipping\n", $file );
        next TABLE;
    }
    %env = %emptyenv;

    open( my $tbl, '<', $file ) or do {
        printf STDERR ( "Can't read %s - %s\n", $file, $! );
        debug( "%s: %s", $file, $! );
        next TABLE;
    };

    if( $file =~ /(?:$systableRE)|(?:$usertableRE)/ ) {
        my $mode = ( stat $tbl )[2];

        # cron disallows write or execute for anyone but owner.
        # Don't enforce for files outside system areas.

        if( $mode & ( S_IWGRP | S_IWOTH | S_IXGRP | S_IXOTH ) ) {
            my $gp  = $mode & ( S_IWGRP | S_IXGRP );
            my $op  = $mode & ( S_IWOTH | S_IXOTH );
            my $who = ( $gp && $op ) ? 'group and other' : $gp ? 'group' : 'other';
            my $wrt = $mode & ( S_IWGRP | S_IWOTH );
            my $xct = $mode & ( S_IXGRP | S_IXOTH );
            my $what =
                ( $wrt && $xct ) ? "write and execute" : $wrt ? 'write' : 'execute';

            debug( "%s skipped: permissions allow %s to %s\n", $file, $who, $what );
        }
    }

    while( <$tbl> ) {

        # Comments, blank lines
        next if( /^\s*(?:#.*)?$/ );

        my $line = $_;

        # Timespec abbreviations
        if( s/^\s*\@(\S+)\s+// ) {
            my $xpn = { reboot   => "99 99 99 99 99",
                        yearly   => "0 0 1 Jan *",
                        annually => "0 0 1 Jan *",
                        monthly  => "0 0 1 *   *",
                        weekly   => "0 0 * *   Sun",
                        daily    => "0 0 * *   *",
                        hourly   => "0 * * *   *",
                      }->{$1};
            $xpn = "88 88 88 88 88" unless( defined $xpn );
            $_   = "${xpn} $_";
        }

        # Quoted assignments, unquoted assignments, job definitions
        if( /^\s*(\w+)\s*=\s*(['"'])(.*)\2$/ ) {
            $env{$1} = $3;
            debug( "$.: $1=$3" );
        } elsif( /^\s*(\w+)\s*=\s*(.*?)\s*$/ ) {
            $env{$1} = $2;
            debug( "$.: $1=$2" );
        } elsif( $job ) {

            # Match job's command, ignoring schedule and (when present) user
            my( $min, $hr, $dom, $mon, $dow, $usr, $cmd );
            s/^\s+//;
            chomp;
            if( $format eq 'system' ) {
                ( $min, $hr, $dom, $mon, $dow, $usr, $cmd ) =
                    split( /\s+/, $_, 7 );
                next unless( defined $cmd );
                next if( defined $user && $usr ne $user );
            } else {
                ( $min, $hr, $dom, $mon, $dow, $cmd ) = split( /\s+/, $_, 6 );
                next unless( defined $cmd );
            }

            # Remove any stdin data & collapse any quoted \ or % in the command
            $cmd =~ s/([^\\])%.*$/$1/;
            $cmd =~ s/(?:\\)([%\\])/$1/g;

            if( $cmd =~ /$matchRE/ ) {
                ++$hitnum;
                $line =~ s/^\s+//;
                chomp $line;
                printf( "%3u)%s:%u %s\n", $hitnum, $file, $., $line );
                my( $nextime, $why ) = timeof( [ $min, $hr, $dom, $mon, $dow ] );
                $nextime =
                    $nextime >= 0
                    ? strftime( "%a %d-%b-%Y %T", localtime( $nextime ) )
                    : "Unknown ($why)";
                printf( "     Next cron run: %s\n", $nextime );
                debug( "%u)%s:%u %s", $hitnum, $file, $., $line );
                debug( "    Next cron run: %s\n", $nextime );

                if( $match == $hitnum ) {
                    next if( $list );
                    dojob(  $cmd,
                              defined $usr  ? $usr
                            : defined $user ? $user
                            : $defaultUser,
                            \%env );
                    last TABLE;
                }
            }
        }
    }  # End of this crontab
    close( $tbl );
}  # End of crontabs

my $sts = 0;
if( defined $job ) {
    unless( $hitnum ) {
        my $where = defined $table ? $table : join( ' ', glob join( ' ', @systables ) );
        printf STDERR ( "No match for %s in %s\n", $matchRE, $where );
        debug( "No match for %s in %s", $matchRE, $where );
        $sts = 1;
    }
} else {

    # Execute from command line
    dojob( $jobcmd, defined $user ? $user : $defaultUser, \%env );
}
if( $debug ) {
    my( $endt, $endu ) = $havegtod ? gettimeofday() : ( time, 0 );
    if( $endu < $startu ) {
        $endt--;
        $endu += 1_000_000;
    }
    $endu -= $startu;
    $endt -= $startt;
    if( $endt < 86400 ) {
        debug(  "Elapsed time: %s\n",
                strftime( '%T', gmtime $endt ) .
                ( $havegtod ? sprintf( '.%06u', $endu ) : '' ) );
    } else {
        debug(  "Elapsed time: %ud %s\n",
                $endt / 86400,
                strftime( '%T', gmtime( $endt % 86400 ) ) .
                ( $havegtod ? sprintf( '.%06u', $endu ) : '' ) );
    }
}
exit $sts;

# Execute identified job
sub dojob {
    my( $cmd, $user, $env ) = @_;

    $cmd = '' unless( defined $cmd );

    debug( "Executing job %s", $cmd );

# Separate command from any stdin data and handle % => \n and \%, \\ substitutions
    my @cmd = split( //, $cmd );
    $cmd = '';
    my $stdin;
    my $p = \$cmd;

    while( @cmd ) {
        my $c = shift @cmd;
        if( $c eq '\\' && @cmd ) {
            $c = shift @cmd;
            if( $c eq '\\' || $c eq '%' ) {
                $$p .= $c;
            } else {
                $$p .= "\\$c";
            }
        } elsif( $c eq '%' ) {
            $$p .= "\n";
            $p = \$stdin;
        } else {
            $$p .= $c;
        }
    }
    unless( defined $cmd && length $cmd ) {
        printf STDERR ( "No command found in job\n" );
        debug( "No command found in job" );
        exit 1;
    }

    # Lookup the job's user & setup environment that depends on user
    my( $name, $pwd, $uid, $gid, $quota, $comment, $gcos, $home, $shell ) =
        getpwnam( $user );
    unless( defined $name ) {
        printf STDERR ( "%s: no such user\n", $user );
        debug( "%s: no such user - %s", $user, $! );
        exit 1;
    }

    # These variables don't carry forward to subsequent jobs.
    # Force LOGNAME (& USER) from /etc/passwd (table can not override LOGNAME)
    # Default HOME from /etc/passwd
    # Default PATH based on UID.
    # SHELL default is already setup - NOT from /etc/passwd

    $env         = { %env, USER => $user, LOGNAME => $user };
    $env->{HOME} = $home unless( exists $env->{HOME} );
    $env->{PATH} = $uid == 0 ? '/usr/sbin:/usr/bin:/sbin:/bin' : '/usr/bin:/bin'
        unless( exists $env->{PATH} );

    my $groups;
    if( $> == 0 ) {
        my %groups = ( $gid => 1 );
        while( my( $gn, $gp, $gi, $gm ) = getgrent() ) {
            my %m = map { $_ => 1 } split( /\s/, $gm );
            $groups{$gi} = 1 if( exists $m{$name} && $gi ne 0 );
        }
        $groups = join(
                ' ',
                $gid, $gid,
                map { $_ != $gid ? $_ : () } sort { $a <=> $b } keys %groups );
    }
    if( $debug ) {
        debug( "Environment" );
        foreach my $e ( sort keys %$env ) {
            debug( " $e = '$env->{$e}'" );
        }
    }
    chomp $cmd;

    # Temp files for job's stdio
    my $jout = File::Temp->new( UNLINK => 1, Suffix => '.crono' );
    my $jin;
    if( defined $stdin ) {
        $jin = File::Temp->new( UNLINK => 1, Suffix => '.croni' );
        chomp $stdin;
        $stdin .= "\n";
        print $jin ( $stdin );
        seek( $jin, 0, SEEK_SET );
        debug( "Data ready for <stdin>, length %u", length $stdin );
    } else {
        open( $jin, '<', '/dev/null' ) or die( "No /dev/null\n" );
    }

    if( defined $pidfile && length $pidfile ) {
        $pidfile = realpath( $pidfile );
        unlink( $pidfile );
    }

    my( $pid, $forksts );
    $forksts = 0;
    if( $detach ) {
    DETACH: {
            if( ( $pid = fork ) ) {
                debug( "Detached process is pid %U\n", $pid );
                if( defined $pidfile && length $pidfile ) {
                    open( my $pf, '>>', $pidfile ) or die( "$pidfile::$!\n" );
                    printf $pf ( "d:%u\n", $pid );
                    close( $pf );
                }
                exit 0;
            }
            if( defined $pid ) {
                setsid();
                chdir( '/' );
                $SIG{'HUP'} = 'IGNORE';
                last DETACH;
            }
            if( $! == EAGAIN ) {
                sleep 6;
                debug( "Retrying fork" );
                redo DETACH;
            } else {
                $forksts = +$!;
                printf STDERR ( "fork: %s\n", $! );
                debug( "fork failed: $!" );
                last DETACH;
            }
        }
    }
    unless( $forksts ) {
    FORK: {
            if( ( $pid = fork ) ) { last FORK; }
            if( defined $pid ) {
                %ENV = %$env;

                umask( 0 );

                if( $> == 0 ) {
                    $! = 0;
                    $( = $gid;
                    $) = $groups;
                    $> = $< = $uid;
                    if( $! ) {
                        printf STDERR (
                                "Unable to assume %s's identity: %s\n",
                                $user, $! );
                        exit 1;
                    }
                }
                chdir( $ENV{HOME} ) || die( "chdir: $!\n" );

                STDOUT->flush;
                STDERR->flush;

                close( STDOUT );
                open( STDOUT, '>&' . fileno( $jout ) ) or die( "STDOUT: $!\n" );
                STDOUT->autoflush( 1 );
                close( STDIN );
                open( STDIN, '<&' . fileno( $jin ) ) or die( "STDIN: $!\n" );

                close( STDERR );
                open( STDERR, '>&' . fileno( STDOUT ) ) or die( "STDERR: $!\n" );
                STDERR->autoflush( 1 );

                exec { $ENV{SHELL} } ( $ENV{SHELL}, '-c', $cmd );
                die( "Can't exec $ENV{SHELL} with $cmd\n" );
            } elsif( $! == EAGAIN ) {
                sleep 6;
                debug( "Retrying fork" );
                redo FORK;
            } else {
                $forksts = +$!;
                printf STDERR ( "fork: %s\n", $! );
                debug( "fork failed: $!" );
                last FORK;
            }
        }

        # Parent continues, wait for child
        my $sts = -1;
        if( defined $pid ) {
            if( defined $pidfile && length $pidfile ) {
                open( my $pf, '>>', $pidfile ) or die( "$pidfile::$!\n" );
                printf $pf ( "j:%u\n", $pid );
                close( $pf );
            }
            if( $debug && $> == 0 ) {
                if( $detach ) {
                    close( STDIN );
                    open( STDIN, '<', '/dev/null' );
                    close( STDOUT );
                    open( STDOUT, '>', '/dev/null' );
                    unless( $debug && $debug == \*STDERR ) {
                        close( STDERR );
                        open( STDERR, '>', '/dev/null' );
                    }
                }
                my @g = split( / /, $groups );
                shift @g;
                foreach my $g ( @g ) {
                    my $n = getgrgid( $g );
                    $g = defined $n ? sprintf( '%u(%s)', $g, $n ) : $g;
                }
                debug(  "Job running as PID %u, uid=%u(%s), gid=%s, groups=%s",
                       $pid, $uid, $name, $g[0], join( ',', @g ) );
            } else {
                debug( "Job running as PID %u", $pid );
            }
            waitpid( $pid, 0 );
            $sts = $? >> 8;
            debug( "Job done, result:%s", $? ? procsts : " success" );
        }
    }
    close( $jin );

    # Collect any output and its disposition
    seek( $jout, 0, SEEK_END );
    my $wantmail = ( exists $env->{MAILTO} && length $env->{MAILTO} )
        || !exists $env->{MAILTO};
    if( $sendmail eq 'discard' ) {
        debug( "Discarding mail" ) if( tell( $jout ) != 0 && $wantmail );
        $wantmail = 0;
    }
    unless( ( my $ol = tell( $jout ) ) != 0 && $wantmail ) {
        close( $jout );
        debug( "No output generated\n" ) if( $ol == 0 );
        return;
    }
    debug( "Generating e-mail" );

    # Handle envelope variables
    my( $mailto, $mailfrom );
    if( exists $env->{MAILTO} ) {
        $mailto = $env->{MAILTO};
        $mailto =~ s/\$(?:\{(\w+)\}|(\w+))/my $v = $env->{$1||$2}; defined $v? $v : ''/ge;
    } else {
        $mailto = $user;
    }

    # Envelope sender
    if( exists $env->{MAILFROM} && length $env->{MAILFROM} ) {
        $mailfrom = $env->{MAILFROM};
        $mailfrom =~
            s/\$(?:\{(\w+)\}|(\w+))/my $v = $env->{$1||$2}; defined $v? $v : ''/ge;
    } else {
        $mailfrom = 'root';
    }

    my $mp =
        $sendmail eq 'display'
        ? 'cat'
        : sprintf( $mailcmd, $mailer, $mailfrom, $mailto );
    open( my $mail, '|-', $mp ) or
        do {
            debug( "Can't start %s", $mp );
            die( "Can't send mail to %mailto : $!\n" );
        };

    $SIG{PIPE} = "IGNORE";

    seek( $jout, 0, SEEK_SET );

    # Generate mail headers
    printf $mail ( <<"HDR", $defaultUser, $mailto );
From: %s (Cron Daemon)
To: %s
HDR

    my $hostname = hostname;
    my $hn       = $hostname;
    $hn =~ s/^([^.]+)\..*$/$1/;

    if( exists $env->{MAILSUBJECT} && length $env->{MAILSUBJECT} ) {
        my $subj = $env->{MAILSUBJECT};
        $subj =~ s/%user%/$env->{USER}/g;
        $subj =~ s/%hostname%/$hn/g;
        $subj =~ s/%cmd%/$cmd/g;
        $subj =~ s/%status%/$sts? "failed" : "success"/ge;
        $subj =~ s/%forkstatus%/$forksts? "failed" : "success"/ge;
        $subj =~ s/%fqdn%/$hostname/g;
        printf $mail ( "Subject: %s\n", $subj );
    } else {
        printf $mail (
                "Subject: Cron <%s@%s> %s%s\n",
                $user, $hn, $cmd, $sts ? " (failed)" : "" );
    }

    my $ct = $env->{CONTENT_TYPE};
    if( defined $ct && length $ct ) {
        $ct =~ s/\n/ /g;
    } else {
        $ct = sprintf( "text/plain; charset=%s", $charset );
    }
    printf $mail ( "Content-Type: %s\n", $ct );

    my $te = $env->{CONTENT_TRANSFER_ENCODING};
    if( defined $te && length $te ) {
        $te =~ s/\n/ /g;
        printf $mail ( "Content-Transfer-Encoding: %s\n", $te );
    }
    for my $e ( sort keys %$env ) {
        printf $mail ( "X-Cron-Env: <%s=%s>\n", $e, $env->{$e} );
    }
    printf $mail (
            "X-ascron-Logfile: %s %s\n",
            $log, strftime( "%d-%b-%Y %T", localtime( time ) ) )
        if( defined $log );
    print $mail ( "\n" );

    # Add body & dispatch
    print $mail ( $_ ) while( <$jout> );
    unless( close( $mail ) ) {
        my $reason = '';
        if( $! != 0 ) {
            $reason = " $!";
        } else {
            $reason = procsts;
        }
        $reason = sprintf(
                "%s:%s\n",
                $sendmail eq 'display' ? 'cat' : $mailer, $reason );
        debug( $reason );
        die( $reason );
    }
    debug( $sendmail eq 'display' ? "Mail would be sent" : "Mail sent" );
    close( $jout );

    return;
}

# Time of next execution by cron
sub timeof {
    my( $timespec ) = @_;

    return ( -1, 'Time::ParseDate is not installed' ) unless( $havetimedate );

    my @xpn;

    for( my $i = 0; $i < @$timespec; ++$i ) {
        my @when;
        my @s = split( /,/, $timespec->[$i] );

        while( @s ) {
            my $f = shift @s;
            $f =~ s,^\*(/.+)$,"$limits[$i][0]-$limits[$i][1]$1",e;

            if( $f =~ m,^([^-]+)-([^-/]+)(?:/(.*))?$, ) {
                my( $low, $high, $step ) = ( $1, $2, $3 );
                $step = 1 unless $step;
                if( $low !~ /^(\d+)/ ) {
                    $low = $namemap[$i]{ lc $low };
                }
                if( $high !~ /^(\d+)/ ) {
                    $high = $namemap[$i]{ lc $high };
                }
                return ( -1, 'Syntax error: invalid range' )
                    unless(    defined( $low )
                            && defined( $high )
                            && $low <= $high
                            && $step =~ /^\d+$/ );

                for( my $j = $low; $j <= $high; $j += $step ) {
                    push @s, $j;
                }
            } else {
                $f = $namemap[$i]{ lc $f } if( $f !~ /^(\d+|\*)$/ );
                $f = $valmap[$i]{$f}       if( defined $f && exists( $valmap[$i]{$f} ) );
                return ( -1, 'Syntax error: invalid name or value' )
                    unless( defined( $f )
                            && ( $f eq '*'
                                 || ( $f >= $limits[$i][0] && $f <= $limits[$i][1] ) ) );
                push @when, $f;
            }
        }
        push @xpn,
            ( @when == 1 && $when[0] eq '*' ) ? ['*'] : [ sort { $a <=> $b } @when ];
    }

    $xpn[5] = [0];
    my $now = time;
    if( $xpn[2][0] ne '*' && $xpn[4][0] ne '*' ) {
        my @x = @{ $xpn[4] };
        $xpn[4] = ['*'];
        my $t1 = xtime( $now, \@xpn );
        return ( -1, 'Failed to resolve month constraint' ) if( $t1 < 0 );
        $xpn[4] = \@x;
        $xpn[2] = ['*'];
        my $t2 = xtime( $now, \@xpn );
        return ( -1, 'Failed to resolve day constraint' ) if( $t2 < 0 );
        return ( $t1 < $t2 ) ? $t1 : $t2;
    }
    return ( xtime( $now, \@xpn ), 'Failed to resolve run time' );
}

# time from spec
sub xtime {
    my( $now, $xpn ) = @_;

    my( $now_sec, $now_min, $now_hour, $now_mday, $now_mon, $now_wday, $now_year ) =
        ( localtime( $now ) )[ 0, 1, 2, 3, 4, 6, 5 ];
    $now_mon++;
    $now_year += 1900;

    my( $tgt_mon, $tgt_mday, $tgt_wday, $tgt_hour, $tgt_min, $tgt_sec, $tgt_year ) =
        ( $now_mon, $now_mday, $now_wday, $now_hour, $now_min, $now_sec, $now_year );

    while( $tgt_year <= $now_year + 1 ) {
        if( $xpn->[3][0] ne '*' ) {
            unless( defined( $tgt_mon = nearest( $tgt_mon, $xpn->[3] ) ) ) {
                $tgt_mon = $xpn->[3][0];
                $tgt_year++;
            }
        }
        if( $xpn->[2][0] ne '*' ) {
            if( $tgt_mon != $now_mon ) {
                $tgt_mday = $xpn->[2][0];
            } else {
                unless( defined( $tgt_mday = nearest( $tgt_mday, $xpn->[2] ) ) ) {
                    $tgt_mday = $xpn->[2][0];
                    $tgt_mon++;
                    if( $tgt_mon > 12 ) {
                        $tgt_mon = 1;
                        $tgt_year++;
                    }
                    next;
                }
            }
        } else {
            $tgt_mday = ( $tgt_mon == $now_mon ? $tgt_mday : 1 );
        }
        if( $xpn->[4][0] ne '*' ) {
            $tgt_wday = nearest( $tgt_wday, $xpn->[4] );
            $tgt_wday = $xpn->[4][0] unless $tgt_wday;

            my( $mon, $mday, $year );
            $tgt_mday = 1 if $tgt_mon != $now_mon;

            my $t = parsedate(
                         sprintf( "%4.4d/%2.2d/%2.2d", $tgt_year, $tgt_mon, $tgt_mday ) );
            ( $mon, $mday, $year ) = (
                              localtime(
                                  parsedate(
                                      "$dow[$tgt_wday]", PREFER_FUTURE => 1, NOW => $t - 1
                                  ) ) )[ 4, 3, 5 ];
            $mon++;
            $year += 1900;

            if( $mon != $tgt_mon || $year != $tgt_year ) {
                $tgt_mon  = $mon;
                $tgt_year = $year;
                $tgt_mday = 1;
                $tgt_wday = (
                        localtime(
                            parsedate(
                                sprintf(
                                    "%4.4d/%2.2d/%2.2d",
                                    $tgt_year, $tgt_mon, $tgt_mday ) ) ) )[6];
                next;
            }
            $tgt_mday = $mday;
        } else {
            unless( $tgt_mday ) {
                $tgt_mday = ( $tgt_mon == $now_mon ? $tgt_mday : 1 );
            }
        }
        if( $xpn->[1][0] ne '*' ) {
            if( $tgt_mday != $now_mday || $tgt_mon != $now_mon || $tgt_year != $now_year )
            {
                $tgt_hour = $xpn->[1][0];
            } else {
                unless( defined( $tgt_hour = nearest( $tgt_hour, $xpn->[1] ) ) ) {
                    $tgt_hour = $xpn->[1][0];
                    my $t = parsedate(
                            sprintf(
                                "%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                $tgt_hour, $tgt_min, $tgt_sec, $tgt_year, $tgt_mon,
                                $tgt_mday ) );
                    ( $tgt_mday, $tgt_mon, $tgt_year, $tgt_wday ) =
                        ( localtime( parsedate( "+ 1 day", NOW => $t ) ) )[ 3, 4, 5, 6 ];
                    $tgt_mon++;
                    $tgt_year += 1900;
                    next;
                }
            }
        } else {
            $tgt_hour = ( $tgt_mday == $now_mday ? $tgt_hour : 0 );
        }
        if( $xpn->[0][0] ne '*' ) {
            if(    $tgt_hour != $now_hour
                || $tgt_mday != $now_mday
                || $tgt_mon != $tgt_mon
                || $tgt_year != $now_year ) {
                $tgt_min = $xpn->[0][0];
            } else {
                unless( defined( $tgt_min = nearest( $tgt_min, $xpn->[0] ) ) ) {
                    $tgt_min = $xpn->[0][0];
                    my $t = parsedate(
                            sprintf(
                                "%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                $tgt_hour, $tgt_min, $tgt_sec, $tgt_year, $tgt_mon,
                                $tgt_mday ) );
                    ( $tgt_hour, $tgt_mday, $tgt_mon, $tgt_year, $tgt_wday ) =
                        ( localtime( parsedate( " + 1 hour", NOW => $t ) ) )
                        [ 2, 3, 4, 5, 6 ];
                    $tgt_mon++;
                    $tgt_year += 1900;
                    next;
                }
            }
        } else {
            if(    $tgt_hour != $now_hour
                || $tgt_mday != $now_mday
                || $tgt_year != $now_year ) {
                $tgt_min = 0;
            }
        }
        if( $xpn->[5][0] ne '*' ) {
            if( $tgt_min != $now_min ) {
                $tgt_sec = $xpn->[5][0];
            } else {
                unless( defined( $tgt_sec = nearest( $tgt_sec, $xpn->[5] ) ) ) {
                    $tgt_sec = $xpn->[5][0];
                    my $t = parsedate(
                            sprintf(
                                "%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                $tgt_hour, $tgt_min, $tgt_sec,
                                $tgt_year, $tgt_mon, $tgt_mday ) );
                    ( $tgt_min, $tgt_hour, $tgt_mday, $tgt_mon, $tgt_year, $tgt_wday ) =
                        ( localtime( parsedate( " + 1 minute", NOW => $t ) ) )
                        [ 1, 2, 3, 4, 5, 6 ];
                    $tgt_mon++;
                    $tgt_year += 1900;
                    next;
                }
            }
        } else {
            $tgt_sec = ( $tgt_min == $now_min ? $tgt_sec : 0 );
        }
        my $date = sprintf(
                "%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                $tgt_hour, $tgt_min, $tgt_sec, $tgt_year, $tgt_mon, $tgt_mday );
        my $result = parsedate( $date, VALIDATE => 1 );

        return $result if( $result );

        my $t = parsedate( $date );
        ( $tgt_hour, $tgt_mday, $tgt_mon, $tgt_year, $tgt_wday ) =
            ( localtime( parsedate( " + 1 second", NOW => $t ) ) )[ 2, 3, 4, 5, 6 ];
        $tgt_mon++;
        $tgt_year += 1900;
        next;
    }
    return -1;
}

# get next entry in list or undef
sub nearest {
    my( $x, $list ) = @_;

    for( my $i = 0; $i < @$list; ++$i ) {
        if( $$list[$i] >= $x ) {
            return $$list[$i];
        }
    }
    return;
}

# Debug log writer
sub debug {
    my $fmt = shift;

    return unless( defined $debug );

    my( $sec, $us ) = $havegtod ? gettimeofday() : ( time, 0 );
    my $ts = strftime( '%T', localtime $sec );
    $ts .= sprintf( '.%06u', $us ) if( $havegtod );

    chomp $fmt;
    $fmt .= "\n";
    return printf $debug ( "%s: %s", $ts, $fmt ) unless( @_ );
    return printf $debug ( "%s: %s", $ts, sprintf( $fmt, @_ ) );
}

# Decode process exit status
sub procsts {
    my $result = '';

    if( $? == -1 ) {
        $result = ' Unknown';
    } else {
        if( $? & 127 ) {
            require Config;
            my $n =
                ( split( ' ', $Config::Config{sig_name} ) )[ $? & 127 ] || '??';
            $result .= sprintf( " killed by signal %u (%s)", $? & 127, $n );
        }
        $result .= sprintf( " exit code %d", $? >> 8 ) if( $? >> 8 );
        $result .= " core dumped"                      if( $? & 128 );
    }
    return $result;
}

__END__

=pod

=head1 NAME

ascron - Run cron jobs from a terminal

=head1 SYNOPSIS

 ascron   command | job-regexp
           --format  --job     --list    --mail-action --locale --match
           --system  --table   --user    --debug=file  --tz      --notz
           --detach  --pidfile
           --help    --man     --version

=head1 DESCRIPTION

I<ascron> runs a command in the environment it would have if run by (Vixie) I<crond>, without
the difficulties of editing a I<crontab> and waiting for I<crond> to notice it.

I<ascron> can select jobs from any installed I<crontab> (user or system), from an uninstalled
I<crontab>, or can run a job defined on the command line.

The Vixie cron extensions are supported in I<crontabs>: named weekdays and months, ranges, step
counts, and @abbreviations (such as @daily).

I<ascron> sets up the environment using the same process as I<crond> does when reading I<crontab>s.

I<ascron> obeys the same enviroment variables as I<crond> for determining the SHELL, PATH, and output
disposition.

Additionally, I<ascron> allows the job's output to be sent to stdout, e-mail, or discarded,.  E-mail
is sent exactly as I<crond> would, obeying the crontab's environment variables.

When running jobs, I<ascron> will (if run as root) run them as the appropriate user, setting the job's
B<UID>, B<GID>, and groups as specified.

See B<EXAMPLES> for how these interact.

=head1 OPTIONS

The following options are used to select the I<crontab>(s) searched, and the job to be run.

B<system> I<crontabs> include the user under which a job runs.  These include F</etc/crontab> and F</etc/cron.d/*>.
B<user> I<crontabs> do not include the user.  The user is implied by the Icrontab>'s location or by the B<--format> option.  The user may also be specified by the B<--user> option, which also implies a default table.

Options contained in F<~/.ascron> will be applied before any specified on the command line.  The B<--no> forms of options may be useful on the command line to override F<~/.ascron>.

=over 4

=item B<-d> B<--debug>=F<file> B<--nodebug>

Writes a detailed log of processing events to F<file>.  F<file> may be '-' for F<stderr>.

While intended for debugging I<ascron>, some of the detail may be helpful for understanding how I<cron> processes a job.

=item B<-D> B<--[no]detach> B<--[no]daemon>

I<ascron> daemonizes itself before running the job.  This frees your terminal when executing long-running jobs, and is how I<crond> runs.

This does not affect B<--debug> output if F<stderr> is specified.

Ues B<--pidfile> if you want to capture the PID of the daemon.

Consider placing B<--detach> in your F<.ascron> if long-running jobs are the norm.

=item B<-f> B<--format>=I<automatic|system>|I<user>

Specifies the format of the I<crontab>(s) read by the command.

I<automatic>, the default, determines the format using B<--table>, B<--user>, and/or B<--job>.

=item B<-j> B<--job>

Specifies the job(s) to be located in the I<crontab>(s).  The command arguments are unanchored regular expressions that match each I<crontab> command.  If more than one argument is specified, they are combined with I<or>; that is, a command is selected if any of the arguments matches.  By default, the first matching command will be used, but B<--match> can specify a subsequent match.

If B<--job> is not specified or B<--nojob>/B<--command>/B<-c> is specified, the command is specified by the command line arguments.

=item B<-l> B<--[no]list>

With B<--job>, lists all matching jobs (and does not execute any).  Useful with multiple matches to determine a value of B<--match> that will select the desired job.

B<--list> can also be used to determine the next time at which  I<crond> will execute matching jobs.

=item B<-M> B<--mail-action>=I<discard>|I<display>|I<send>

Output on F<stdout> or F<stderr> from I<cron> jobs is (usually) e-mailed; the destination, source, subject, and format are controlled by environment variables set in the I<crontab>.

By default, I<ascron> faithfully emulates this behavior -- which can be inconvenient for debugging jobs.  B<--mail-action> can override the default action so that the mail message is displayed (on F<stdout>) or discarded.

=item B<-p> B<--pidfile>=F<file> B<--nopidfile>

Write the PID of the job to F<file> as I<j:<pid>>.

When daemonizing, also write the PID of the daemon to F<file> as I<d:<pid>>.  The order of the PIDs is unpredictable.

=item B<-t> B<--table>=F<file> B<--notable>

Selects the I<crontab> file used to extract environment variables, and (with B<--job>) the command.

Note that without B<--job>, the job defined on the command line is processed as if it is located at the end of the I<crontab>.  Thus, if an environment variable is re-defined in a I<crontab>, the last definition is used.

If not specified or defaulted, all system tables are read.

=item B<-u> B<--user>=I<name> B<--nouser>

Specifies the username to be matched when locating a job or table; under which the job executes.

If B<--table> is not specified, B<--user> implies the user's private table.

If a username is required, but not determined implicitly or by B<--user>, the username is obtained from the opertor's (effective) I<UID>.

=item B<-m> B<--match>=I<n>

Specifies that the I<n>th matching job is to be used.  The first (and default) match is numbered 1.

=item B<-z> B<--tz>=i<zone>  B<-Z> B<--notz>

I<crond> implementations vary considerably in whether jobs have B<TZ> (the timezone) in their environment, and if they do, where it comes from and what it contains.

I<ascron> attempts to set B<TZ> from its environment, or failing that from several system commands and files.

To specify the value of B<TZ> for I<ascron> jobs, use B<--tz>=I<zone>, where I<zone> can be any string (but should be what your I<crond> provides).

To omit B<TZ>, use B<--notz>.

=item B<-L> B<--locale>=I<specifier> B<--nolocale>

Specifies the locale from which the default codeset for e-mails is determined.  See L<Subtleties>, below for details.

=item B<--version>

Displays the version number of I<ascron>.

=item B<--help>

Displays the help sections of the manual.

=item B<--man>

Displays the manual.


=back

=head1 Subtleties

There are two things that I<ascron> can't or doesn't emulate.

=head2 Locale considerations

By default, the operator's locale is used to determine the default codeset for e-mail and by commands directly executed by the C<SHELL>.
However, I<crond> runs as a daemon, and I<ascron> can't determine what locale it would use.  The operator's locale
is used since there's a reasonable chance that it is also the system default, and the C<C/POSIX> locale is out of favor.

However, C<LC_COLLATE> is set to C<C> for compatibility with I<crond>.

To get the right results for your system, you can run I<ascron> C<LC_ALL=fr_FR ascron ...>, or use B<--locale>.

If C<LC_*> environment variables are set in tables, they apply to (subsequent) jobs.

=head2 Multi-level security

I<crond> identifies its jobs to MLS-equipped systems (e.g. SELINUX, APPARMOR) so that they get the correct security contexts assigned.

I<ascron> does not support this.  You may see different behaviors as a result.

=head1 F<stdin> for I<cron> jobs

If a I<crontab> command contains an unquoted '%', everything after the first unquoted '%' is sent to the job's F<stdin>.
Any subsequent unquoted '%'s are converted to newlines ('\n'), and if the input does not end in a newline, one is added.
Quoting is with backslash ('\'); only '%' and '\' may be quoted; in any other case, both the backslash and the following
character are passed-through.

If a I<crontab> command does not contain an unquoted '%', F<stdin> is attached to F</dev/null>.

=head1 Mail from I<crond>

Determining how and when e-mail is sent by I<crond> requires a careful reading of documents and code.  This is how I<ascron>
implements it (some text borrowed from I<crond>'s I<man> pages:

I<crond> (and thus I<ascron>) may send e-mail when a job generates output on F<stdout> or F<stdin>.

In addition to B<LOGNAME>, B<HOME>, and B<SHELL>, cron(8) looks at the B<MAILTO> variable if a mail needs to be sent as a  result  of
running any commands in that particular crontab.  If MAILTO is defined (and non-empty), mail is sent to the specified address.
If B<MAILTO> is defined but empty (B<MAILTO="">), no mail is sent.  Otherwise,  mail  is  sent  to  the  owner  of  the crontab.

If B<MAILFROM> is defined (and non-empty),  it is used as the envelope sender address, otherwise, ``B<root>'' is used.

B<Note:>  Both  B<MAILFROM>  and B<MAILTO> variables' values are expanded using the I<crontab>'s environment, so setting them as in
the following example works as expected:

    MAILFROM=cron-$USER@cron.com ($USER is replaced by the system user)

By default, cron sends a mail using the 'I<Content-Type:>' header of 'I<text/plain>' with the 'I<charset=>' parameter set  to  the
'charmap/codeset' of the locale in which crond(8) is started up, i.e., either the default system locale, if no LC_* environment
variables are set, or the locale specified by the LC_* environment variables (see locale(7)).

Different  character  encodings  can  be used for mailing cron job outputs by setting the B<CONTENT_TYPE> and
B<CONTENT_TRANSFER_ENCODING> variables in a crontab to the correct values of the mail headers of those names.

If defined, B<MAILSUBJECT> can be used to provide a custom I<Subject> header.  It is subject to expansion with the following
variables (but not environment variables):

=over 4

=item * %cmd%        - expands to the job's command line

=item * %forkstatus% - expands to I<success> or I<failure> according to I<ascron>'s ability to fork a child process to run the command

=item * %fqdn%       - expands to the fully qualified domain name of the host.

=item * %hostname%   - expands to the first "word" of the hostname

=item * %status%     - expands to I<success> or I<failure> according to the commands exit status

=item * %user%       - expands to B<$USER>

=back

=head1 EXAMPLES

=head2 locate and run first job matching I<Backup> in the system tables

    ascron --job Backup

=head2 Run I<Backup> from the system tables from a daemon

    ascron --job Backup --detach --pidfile=Backup.pid

=head2 Locate and run first job matching I<Backup> or I<rsync> in I<root>'s private table

    ascron --job Backup rsync --user=root

=head2 List all jobs matching I<Backup> in the system tables

    ascron --job Backup --list

=head2 List all jobs matching I<Backup> or I<update> in I<root>'s private table

Note that the mstch number (for B<--match>) precedes each line, and that the line number in the I<crontab> follows the filename.

    ascron --list --job Backup update -u root
    1)/var/spool/cron/root:11 17 5 * * *   cd /Network ; CA/updateaccess >www/AccessOfDay.html 2>/dev/null
    2)/var/spool/cron/root:23 12 2 * * *   nice -n19 /root/tools/Backup
    3)/var/spool/cron/root:30 43 3 * * 4   /root/tools/update-leap -p 4
    4)/var/spool/cron/root:32 37 2 * * Wed /etc/init.d/BlockCountries start -update

=head2 Locate and run F<crontest> in an uninstalled I<crontab>

This might be an application I<crontab> destined for F<cron.d>.

    cat apptable
    MAILSUBJECT=%fqdn% - %cmd% %status% for %user%
    CRONJOB=1

    * * * * * appuser /app/tools/crontest "a" "b-$$" "q"%stdin%data%

    ascron --user=appuser --table=apptable --job test --format=system --mail=display
    From: root (Cron Daemon)
    To: appuser
    Subject: myhost.example.net - /app/tools/crontest "a" "b-$$" "q" success for a[[iser
    Content-Type: text/plain; charset=UTF-8
    X-Cron-Env: <CRONJOB=1>
    X-Cron-Env: <HOME=/home/litt>
    X-Cron-Env: <LOGNAME=litt>
    ...
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         1  0.0  0.0   1740   576 ?        Ss   Oct19   0:02 init [5]

=head2 Execute a F<ps> command as if it was contained in F</etc/crontab>

    ascron --table=/etc/crontab --mail=display ps aux

=head1 BUGS

Report any bugs, feature requests and/or patches on the issue tracker,
located at F<https://github.com/tlhackque/ascron/issues>.  In the
event that the project moves, contact the author directly.

=head1 AUTHOR

Timothe Litt  E<lt>litt@acm.orgE<gt>

=head1 COPYRIGHT and LICENSE

Copyright (c) 2022 Timothe Litt

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the author shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the author.

Any modifications to this software must be clearly documented by and
attributed to their author, who is responsible for their effects.

Bug reports, suggestions and patches are welcomed by the original author.

=head1 SEE ALSO

I<cron(8)> I<crond(8)> I<crontab(1)> I<crontab(1p)> I<crontab(5)>

=cut
